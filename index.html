<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>도형심리테스트 (GPTI)</title>
<style>
  :root{--accent:#2a2a75;--frame:#c58a6a}
  body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans KR";background:#fbf7f5;color:#222;margin:0;padding:18px;text-align:center}
  h1{color:var(--accent);margin:0 0 6px;font-size:20px}
  p.small{color:var(--accent);font-size:13px;margin:0 0 12px}
  /* board (360x360 ~ 12cm) */
  #board{position:relative;width:360px;height:360px;margin:20px auto;border:2px solid var(--frame);background:#fff;touch-action:none}
  /* inner (6cm) */
  #inner{position:absolute;width:180px;height:180px;left:50%;top:50%;transform:translate(-50%,-50%);border:2px dashed #e8cfc0;pointer-events:none}
  /* shape buttons */
  .toolbar{display:flex;gap:8px;justify-content:center;margin:8px 0;flex-wrap:wrap}
  .tool{padding:8px 12px;border-radius:8px;border:1px solid #bbb;background:#fff;cursor:pointer;font-size:18px}
  .tool.active{background:#efeefc;border-color:var(--accent);box-shadow:0 4px 10px rgba(42,42,117,0.06)}
  /* dynamic shapes as absolute elements */
  .placed{position:absolute;touch-action:none;display:flex;align-items:center;justify-content:center;user-select:none}
  .badge{position:absolute;right:2px;bottom:2px;background:var(--accent);color:#fff;font-size:11px;padding:2px 4px;border-radius:6px}
  /* controls */
  #sizeWrapper{display:none;align-items:center;gap:8px;justify-content:center;margin-top:8px}
  input[type="range"]{width:160px}
  .actions{margin-top:10px;display:flex;gap:8px;justify-content:center;flex-wrap:wrap}
  button.action{background:var(--accent);color:#fff;border:none;padding:8px 12px;border-radius:8px;cursor:pointer}
  button.ghost{background:#fff;border:1px solid #cfcfcf;padding:8px 12px;border-radius:8px;cursor:pointer}
  #resultCard{width:360px;margin:16px auto;text-align:left}
  .card{background:#fff;padding:12px;border-radius:10px;box-shadow:0 8px 18px rgba(0,0,0,0.06)}
  .outTitle{font-weight:600;color:#2a2a75;margin-bottom:6px}
  .line{margin:6px 0}
  @media(max-width:420px){#board{width:320px;height:320px}#resultCard{width:320px}}
</style>
</head>
<body>

<h1>○△□S 도형심리테스트</h1>
<p class="small">1) 가장 마음에 드는 도형 1개를 골라(크기/위치 상관없이) 3번 배치하세요. 2) 나머지 도형은 각각 1번씩 배치하세요.</p>

<!-- board -->
<div id="board" aria-label="시험지 영역">
  <div id="inner" aria-hidden="true"></div>
</div>

<!-- tools -->
<div class="toolbar" role="toolbar" aria-label="도형 선택">
  <button class="tool active" data-shape="circle">○</button>
  <button class="tool" data-shape="triangle">△</button>
  <button class="tool" data-shape="square">□</button>
  <button class="tool" data-shape="wave">S</button>
</div>

<!-- size control shown when a placed shape is selected -->
<div id="sizeWrapper">
  <label>크기</label>
  <input id="sizeRange" type="range" min="30" max="140" value="60" />
  <span id="sizeLabel">60</span> px
</div>

<div class="actions">
  <button id="undo" class="ghost">Undo</button>
  <button id="clear" class="ghost">초기화</button>
  <button id="analyze" class="action">결과 보기</button>
</div>

<div id="resultCard">
  <div class="card">
    <div class="outTitle">검사 결과</div>
    <div id="output">도형을 배치한 뒤 '결과 보기'를 누르면 해석이 표시됩니다. (해석의 이유는 제공되지 않습니다.)</div>
  </div>
</div>

<script>
/* ===== 기본 상태 ===== */
const board = document.getElementById('board');
const inner = document.getElementById('inner');
const tools = document.querySelectorAll('.tool');
const sizeWrapper = document.getElementById('sizeWrapper');
const sizeRange = document.getElementById('sizeRange');
const sizeLabel = document.getElementById('sizeLabel');
const undoBtn = document.getElementById('undo');
const clearBtn = document.getElementById('clear');
const analyzeBtn = document.getElementById('analyze');
const output = document.getElementById('output');

let currentTool = 'circle';
let placed = []; // {id,type,left,top,size,order,el}
let orderCounter = 0;
let selectedId = null;

/* 툴 선택 */
tools.forEach(btn=>{
  btn.addEventListener('click', ()=>{
    tools.forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    currentTool = btn.dataset.shape;
    selectedId = null; hideSize();
  });
});

/* 보드 클릭 => 새 도형 배치 (pointer events to support touch) */
board.addEventListener('pointerdown', (e)=>{
  // ignore if clicked on an existing placed element (we handle selection separately)
  if (e.target !== board && e.target.closest('.placed')) return;
  const rect = board.getBoundingClientRect();
  const x = (e.clientX - rect.left);
  const y = (e.clientY - rect.top);
  // clamp within board
  const s = parseInt(sizeRange.value,10);
  const left = Math.max(0, Math.min(board.clientWidth - s, x - s/2));
  const top = Math.max(0, Math.min(board.clientHeight - s, y - s/2));
  addShape(currentTool, left, top, s);
});

/* 도형 추가 함수: SVG for circle and S-text for S; triangle/square use SVG too */
function addShape(type,left,top,size){
  orderCounter++;
  const id = 'p' + Date.now() + Math.random().toString(36).slice(2,7);
  const el = document.createElement('div');
  el.className = 'placed';
  el.style.left = left + 'px';
  el.style.top = top + 'px';
  el.style.width = size + 'px';
  el.style.height = size + 'px';
  el.dataset.id = id;
  el.dataset.type = type;
  el.dataset.order = orderCounter;
  el.style.zIndex = orderCounter + 10;

  // inner content: use inline SVG for circle/triangle/square; use big text 'S' for wave
  if (type === 'circle'){
    el.innerHTML = `<svg width="100%" height="100%" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
      <circle cx="50" cy="50" r="44" stroke="#2a2a75" stroke-width="6" fill="none" />
    </svg><div class="badge">${orderCounter}</div>`;
  } else if (type === 'triangle'){
    el.innerHTML = `<svg width="100%" height="100%" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
      <polygon points="50,8 8,88 92,88" stroke="#2a2a75" stroke-width="6" fill="none"/>
    </svg><div class="badge">${orderCounter}</div>`;
  } else if (type === 'square'){
    el.innerHTML = `<svg width="100%" height="100%" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
      <rect x="8" y="8" width="84" height="84" stroke="#2a2a75" stroke-width="6" fill="none"/>
    </svg><div class="badge">${orderCounter}</div>`;
  } else { // wave -> show large 'S' character
    el.style.display = 'flex'; el.style.alignItems='center'; el.style.justifyContent='center';
    el.innerHTML = `<div style="font-size:calc(60% + 0.4em);font-weight:700;color:#2a2a75">S</div><div class="badge">${orderCounter}</div>`;
  }

  // append and record
  board.appendChild(el);
  placed.push({id,type,left,top,size,order:orderCounter,el});
  // make element interactive (select/drag)
  makeInteractive(el);
}

/* make placed element selectable and draggable */
function makeInteractive(el){
  // pointerdown on element selects it (prevent board click)
  el.addEventListener('pointerdown', (ev)=>{
    ev.stopPropagation();
    // select
    selectedId = el.dataset.id;
    // show size control and set values
    sizeWrapper.style.display = 'flex';
    sizeRange.value = parseInt(el.style.width,10);
    sizeLabel.textContent = sizeRange.value;
    // highlight visually by box-shadow
    el.style.boxShadow = '0 6px 18px rgba(42,42,117,0.12)';
    // prepare drag
    const rect = board.getBoundingClientRect();
    const startX = ev.clientX;
    const startY = ev.clientY;
    const startLeft = parseFloat(el.style.left);
    const startTop = parseFloat(el.style.top);
    function onMove(mv){
      const dx = mv.clientX - startX;
      const dy = mv.clientY - startY;
      let nl = Math.max(0, Math.min(board.clientWidth - el.clientWidth, startLeft + dx));
      let nt = Math.max(0, Math.min(board.clientHeight - el.clientHeight, startTop + dy));
      el.style.left = nl + 'px';
      el.style.top = nt + 'px';
      // update placed record
      const rec = placed.find(p=>p.id===el.dataset.id);
      if (rec){ rec.left = nl; rec.top = nt; }
    }
    function up(){
      window.removeEventListener('pointermove', onMove);
      window.removeEventListener('pointerup', up);
      // remove highlight after small delay
      setTimeout(()=>{ if (selectedId === el.dataset.id) el.style.boxShadow = '0 4px 10px rgba(0,0,0,0.04)'; },120);
    }
    window.addEventListener('pointermove', onMove);
    window.addEventListener('pointerup', up);
  });

  // double-click (or long press) could deselect — but we provide clicking elsewhere to deselect
}

/* size range change */
sizeRange.addEventListener('input', ()=>{
  sizeLabel.textContent = sizeRange.value;
  if (!selectedId) return;
  const rec = placed.find(p=>p.id===selectedId);
  if (!rec) return;
  rec.size = parseInt(sizeRange.value,10);
  rec.el.style.width = rec.size + 'px';
  rec.el.style.height = rec.size + 'px';
});

/* hide size control */
function hideSize(){ sizeWrapper.style.display = 'none'; }

/* click outside to deselect */
document.addEventListener('pointerdown', (e)=>{
  if (!e.target.closest('.placed') && !e.target.closest('.tool') && !e.target.closest('#sizeWrapper')){
    // deselect
    if (selectedId){
      const rec = placed.find(p=>p.id===selectedId);
      if (rec) rec.el.style.boxShadow = '0 4px 10px rgba(0,0,0,0.04)';
    }
    selectedId = null; hideSize();
  }
});

/* Undo: remove last placed */
undoBtn.addEventListener('click', ()=>{
  if (placed.length === 0) return;
  const last = placed.pop();
  last.el.remove();
  orderCounter = Math.max(0, orderCounter - 1);
  selectedId = null; hideSize();
});

/* Clear */
clearBtn.addEventListener('click', ()=>{
  if (!confirm('모든 도형을 지우시겠습니까?')) return;
  placed.forEach(p=>p.el.remove());
  placed = []; orderCounter = 0; selectedId = null; hideSize();
  output.innerHTML = '초기화되었습니다.';
});

/* 분석(결과 생성) */
analyzeBtn.addEventListener('click', ()=>{
  if (placed.length < 4) {
    alert('모든 도형을 배치해 주세요. (선호 도형 3회 + 나머지 3개 도형 각 1회)');
    return;
  }
  // compute counts by type and choose dominant (the one with count 3 if present, else max)
  const counts = {};
  placed.forEach(p => counts[p.type] = (counts[p.type]||0) + 1);
  let dominant = Object.keys(counts).find(k => counts[k] === 3) || Object.keys(counts).reduce((a,b)=> (counts[a]||0) >= (counts[b]||0) ? a : b);
  // zone function (row, col)
  function zone(p){
    const cx = p.left + p.size/2;
    const cy = p.top + p.size/2;
    const col = cx < board.clientWidth/3 ? '좌측' : cx > board.clientWidth*2/3 ? '우측' : '중앙';
    const row = cy < board.clientHeight/3 ? '상단' : cy > board.clientHeight*2/3 ? '하단' : '중단';
    return {row,col};
  }
  // base profiles
  const profiles = {
    circle:{
      title:'○ 동그라미',
      lines:[
        '감정과 공감 능력이 매우 발달해 사람들과의 교류에서 안정감을 느끼는 경향이 큽니다.',
        '타인의 기분을 읽고 배려하는 데 능숙하며, 갈등 상황에서도 중재자 역할을 잘 수행합니다.',
        '관계 지향적이며 소속감과 협력을 통해 자기의 정체성을 다지는 경우가 많습니다.',
        '감성적 직관과 세심한 관찰로 인간관계에서 신뢰를 쌓는 힘이 있습니다.',
        '반면 과도한 타인 배려는 정서적 소진으로 이어질 수 있으니 자기관리도 중요합니다.'
      ],
      scent: '은은하고 포근한 플로럴 또는 파우더리 계열의 향이 어울립니다.'
    },
    triangle:{
      title:'△ 세모',
      lines:[
        '목표를 명확히 설정하고 그 목표를 향해 추진하는 의지와 결단력이 탁월합니다.',
        '리더십을 발휘하며 조직이나 집단에서 방향을 제시하는 역할을 잘 수행합니다.',
        '도전과 경쟁 속에서 동기를 얻고, 높은 성취욕으로 스스로를 밀어붙이는 경향이 있습니다.',
        '실행력이 강해 계획을 빠르게 행동으로 옮기지만 때로는 타인의 감정을 배려하는 균형이 필요합니다.',
        '구체적 성과를 중시하는 성향으로 문제 해결 능력과 책임감이 돋보입니다.'
      ],
      scent: '상쾌한 시트러스 계열 또는 약간의 스파이시 톤이 조화를 이룹니다.'
    },
    square:{
      title:'□ 네모',
      lines:[
        '구조적 사고와 계획성이 강해 일의 완성도를 높이려는 성향이 뚜렷합니다.',
        '안정과 책임을 중시하며 신중한 판단으로 주변의 신뢰를 받습니다.',
        '체계적인 접근을 통해 장기적 목표를 이루는 능력이 뛰어납니다.',
        '변화보다 지속 가능한 방법을 선호하며 세심한 준비로 리스크를 관리합니다.',
        '과도한 규칙 준수는 융통성을 낮출 수 있으니 유연성 확보가 도움이 됩니다.'
      ],
      scent: '우디하거나 허브 계열의 차분하고 안정감 있는 향이 어울립니다.'
    },
    wave:{
      title:'S (물결형)',
      lines:[
        '창의적 상상력과 유연한 사고로 색다른 관점을 제시하는 능력이 뛰어납니다.',
        '즉흥적 발상이나 감각적 표현에 강하며 예술적 감수성이 도드라집니다.',
        '틀에 얽매이지 않는 자유로운 태도로 새로운 시도를 즐기며 환경에 적응력이 좋습니다.',
        '다만 구조적 반복작업에서는 집중이 흐트러질 수 있으니 필요한 경우 루틴을 보완하세요.',
        '감각적 직관을 현실적 목표와 연결하면 창조적 성과를 크게 확장할 수 있습니다.'
      ],
      scent: '머스크·바닐라 계열의 자유롭고 은은한 감성향이 어울립니다.'
    }
  };

  // compose rich 5~7 lines for the dominant personality:
  const profile = profiles[dominant];
  // pick up to 5 lines from base lines (if fewer, repeat with variation)
  const baseLines = profile.lines.slice();
  const chosenLines = baseLines.slice(0,5);

  // adjust lines by location prominence: if majority of that type are in 상단/하단/우측/좌측, add a tailoring line
  const locCounts = {상단:0,중단:0,하단:0,좌측:0,중앙:0,우측:0};
  placed.filter(p=>p.type===dominant).forEach(p=>{
    const z = zone(p);
    locCounts[z.row]++; locCounts[z.col]++;
  });
  // find prominent row or col
  const prominentRow = ['상단','중단','하단'].reduce((a,b)=>locCounts[a]>locCounts[b]?a:b);
  const prominentCol = ['좌측','중앙','우측'].reduce((a,b)=>locCounts[a]>locCounts[b]?a:b);
  let locLine = '';
  if (prominentRow === '상단') locLine = '현재 이 성향이 매우 활성화되어 실제 행동으로 잘 드러나는 시기입니다.';
  else if (prominentRow === '중단') locLine = '내면에 잠재된 힘이 있어 차분히 준비하면 외부로 발현될 가능성이 큽니다.';
  else locLine = '해당 영역의 에너지가 다소 낮아지거나 부담이 느껴질 수 있으니 주의가 요망됩니다.';
  // horizontal nuance
  if (prominentCol === '우측') locLine += ' 또한 외향적 표현과 자신감이 지금의 강점으로 작용합니다.';
  else if (prominentCol === '좌측') locLine += ' 과거의 경험이나 내적 성찰이 현재의 행동 양식에 영향을 주고 있습니다.';
  else locLine += ' 전반적으로 균형이 잡혀 안정적인 모습입니다.';

  // Build final lines: pick 4 base sentences + locLine + one integrative sentence
  const finalLines = [];
  finalLines.push(chosenLines[0]);
  finalLines.push(chosenLines[1]);
  finalLines.push(chosenLines[2]);
  finalLines.push(chosenLines[3]);
  finalLines.push(locLine);
  // integrative
  finalLines.push('종합적으로 보면 본인은 자신만의 강점을 현실적으로 활용할 줄 아는 유형으로, 상황에 따라 약간의 조정만으로 더 큰 성취를 기대할 수 있습니다.');

  // scent
  const scentLine = profiles[dominant].scent;

  // Output only the result text (no reasoning)
  let html = `<div class="line"><strong>${profiles[dominant].title} — 주요 성향</strong></div>`;
  finalLines.forEach(l => html += `<div class="line">• ${l}</div>`);
  html += `<hr style="border:none;border-top:1px dashed #eee;margin:10px 0">`;
  html += `<div class="line"><strong>추천 향기</strong></div><div class="line">• ${scentLine}</div>`;

  output.innerHTML = html;
});
</script>
</body>
</html>