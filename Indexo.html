<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>○△□S 도형 테스트</title>
<style>
  :root{
    --bg:#fbf6f4;
    --title:#3c2f91; /* purple */
    --frame:#b9764f; /* brown */
    --muted:#9a8b8a;
    --accent:#3c2f91;
    --btn-bg:#fff;
    --btn-border:#e6e6e6;
  }
  html,body{height:100%;margin:0}
  body{
    font-family: "Pretendard","Noto Sans KR",system-ui,-apple-system,Arial;
    background:var(--bg);
    color:#222;
    display:flex;
    flex-direction:column;
    align-items:center;
    padding:20px 16px 40px;
  }

  h1{
    color:var(--title);
    font-size:34px;
    margin:8px 0 6px;
    letter-spacing:2px;
  }
  .subtitle{
    color:var(--title);
    text-align:center;
    font-size:14px;
    margin:0 0 18px;
  }

  /* board area (visual sizes approximate 12cm -> 360px, inner 6cm -> 180px) */
  .board-wrap{position:relative;width:420px;max-width:92vw}
  #board{
    width:360px;height:360px;margin:0 auto;
    background: #fff;
    border:4px solid var(--frame);
    box-sizing:border-box;
    position:relative;
    touch-action:none;
  }
  /* inner dashed square centered (6cm) */
  #inner {
    position:absolute;
    width:180px;height:180px;
    left:50%;top:50%; transform:translate(-50%,-50%);
    border:4px dashed rgba(183,132,112,0.35);
    box-sizing:border-box;
    pointer-events:none;
  }

  /* tool buttons (rounded squares) */
  .tools{display:flex;gap:12px;justify-content:center;margin-top:18px;flex-wrap:wrap}
  .tool{
    width:64px;height:64px;border-radius:14px;border:2px solid var(--btn-border);
    display:flex;align-items:center;justify-content:center;background:var(--btn-bg);
    font-size:28px;cursor:pointer;box-shadow:0 6px 20px rgba(60,47,145,0.06);
    transition:transform .12s, background .12s, border-color .12s;
  }
  .tool:active{transform:translateY(2px)}
  .tool.active{background:#efeefc;border-color:var(--accent);box-shadow:0 10px 26px rgba(60,47,145,0.14)}
  /* action buttons */
  .actions{display:flex;gap:12px;justify-content:center;margin-top:12px;flex-wrap:wrap}
  .btn{
    padding:10px 16px;border-radius:10px;border:1px solid var(--btn-border);
    background:#fff;color:var(--accent);font-weight:600;cursor:pointer;
  }
  .btn.primary{background:var(--accent);color:#fff;border:none;box-shadow:0 6px 18px rgba(60,47,145,0.16)}

  /* placed shapes styling (absolute elements) */
  .placed{
    position:absolute; touch-action:none; user-select:none; display:flex; align-items:center; justify-content:center;
    box-sizing:border-box; border-radius:8px;
  }
  .placed .badge{
    position:absolute; right:4px; bottom:4px; background:var(--accent); color:#fff; font-size:11px; padding:2px 6px; border-radius:8px;
  }
  /* resize handle */
  .handle{
    position:absolute; width:16px;height:16px; right:-8px; bottom:-8px; background:#fff; border:2px solid var(--accent); border-radius:6px;
    box-shadow:0 4px 10px rgba(0,0,0,0.08); touch-action:none;
  }

  /* result card */
  #resultBox{width:360px;margin:18px auto 0;text-align:left}
  .card{background:#fff;padding:14px;border-radius:12px;box-shadow:0 12px 30px rgba(0,0,0,0.06)}
  .card h3{margin:0 0 8px;color:var(--accent)}
  .line{margin:8px 0;color:#222;line-height:1.6}
  .scent{margin-top:8px;color:#4b4b4b;font-weight:600}

  @media (max-width:420px){
    #board{width:320px;height:320px}
    #inner{width:160px;height:160px}
    .tools .tool { width:56px;height:56px;font-size:24px }
    #resultBox, .card { width:320px }
  }
</style>
</head>
<body>

  <h1>○△□S 도형 테스트</h1>
  <div class="subtitle">1) 가장 마음에 드는 도형 1개를 골라(크기/위치 상관없이) 3번 배치하세요. 2) 나머지 도형은 각각 1번씩 배치하세요.</div>

  <div class="board-wrap">
    <div id="board" aria-label="시험지 캔버스">
      <div id="inner" aria-hidden="true"></div>
      <!-- placed elements will be appended here -->
    </div>
  </div>

  <div class="tools" role="toolbar" aria-label="도형 선택">
    <div class="tool active" data-shape="circle" title="동그라미">○</div>
    <div class="tool" data-shape="triangle" title="세모">△</div>
    <div class="tool" data-shape="square" title="네모">□</div>
    <div class="tool" data-shape="wave" title="S">S</div>
  </div>

  <div class="actions">
    <button id="undo" class="btn">Undo</button>
    <button id="reset" class="btn">초기화</button>
    <button id="analyze" class="btn primary">결과 보기</button>
  </div>

  <div id="resultBox" aria-live="polite">
    <div class="card">
      <h3>검사 결과</h3>
      <div id="resultContent">
        <div class="line">도형을 배치한 뒤 '결과 보기'를 눌러주세요.</div>
      </div>
    </div>
  </div>

<script>
/* ==== 상태값 ==== */
const board = document.getElementById('board');
const tools = document.querySelectorAll('.tool');
const maxCount = 6;
let currentTool = 'circle';
let placed = []; // {id,type,left,top,size,order,el}
let orderCounter = 0;
let selected = null;
const resultContent = document.getElementById('resultContent');

/* 초기 툴 선택 UI */
tools.forEach(t=>{
  t.addEventListener('click', ()=> {
    tools.forEach(x=>x.classList.remove('active'));
    t.classList.add('active');
    currentTool = t.dataset.shape;
    deselect();
  });
});

/* 보드에 탭하면 새 도형 배치 (좌표는 터치/마우스에 맞춰 계산) */
board.addEventListener('pointerdown', (ev)=>{
  // if clicking an existing placed element, selection handled elsewhere
  if (ev.target !== board) return;
  if (placed.length >= maxCount) {
    alert('최대 6개까지만 배치할 수 있습니다.');
    return;
  }
  const rect = board.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  const y = ev.clientY - rect.top;
  addPlaced(currentTool, x, y, 60); // default size 60
});

/* 추가함수: 도형 생성 (SVG or text for S), 엘리먼트에 drag/resize 붙임 */
function addPlaced(type, x, y, size){
  orderCounter++;
  const id = 'p'+Date.now()+Math.random().toString(36).slice(2,6);
  const el = document.createElement('div');
  el.className = 'placed';
  el.style.left = (x - size/2) + 'px';
  el.style.top = (y - size/2) + 'px';
  el.style.width = size + 'px';
  el.style.height = size + 'px';
  el.dataset.id = id;
  el.dataset.type = type;
  el.dataset.order = orderCounter;
  el.style.zIndex = 100 + orderCounter;

  // content
  if (type === 'circle'){
    el.innerHTML = `<svg viewBox="0 0 100 100" width="100%" height="100%"><circle cx="50" cy="50" r="42" stroke="#3c2f91" stroke-width="6" fill="none"/></svg><div class="badge">${orderCounter}</div>`;
  } else if (type === 'triangle'){
    el.innerHTML = `<svg viewBox="0 0 100 100" width="100%" height="100%"><polygon points="50,8 8,92 92,92" stroke="#3c2f91" stroke-width="6" fill="none"/></svg><div class="badge">${orderCounter}</div>`;
  } else if (type === 'square'){
    el.innerHTML = `<svg viewBox="0 0 100 100" width="100%" height="100%"><rect x="8" y="8" width="84" height="84" stroke="#3c2f91" stroke-width="6" fill="none"/></svg><div class="badge">${orderCounter}</div>`;
  } else { // S as big letter
    el.innerHTML = `<div style="font-size:calc(36px + 1.2vw); color:#3c2f91; font-weight:700;">S</div><div class="badge">${orderCounter}</div>`;
  }

  // add resize handle
  const handle = document.createElement('div');
  handle.className = 'handle';
  el.appendChild(handle);

  board.appendChild(el);
  const rec = {id,type,left:x - size/2,top:y - size/2,size,order:orderCounter,el};
  placed.push(rec);

  makeInteractive(el, handle, rec);
}

/* 상호작용: 클릭 선택, drag 이동, handle로 resize */
function makeInteractive(el, handle, rec){
  // select on pointerdown
  el.addEventListener('pointerdown', (ev)=>{
    ev.stopPropagation();
    select(rec.id);
    // start dragging only if not on handle
    if (ev.target === handle) return;
    const rect = board.getBoundingClientRect();
    const startX = ev.clientX, startY = ev.clientY;
    const startLeft = parseFloat(el.style.left), startTop = parseFloat(el.style.top);
    function move(mv){
      const nx = Math.max(0, Math.min(board.clientWidth - rec.size, startLeft + (mv.clientX - startX)));
      const ny = Math.max(0, Math.min(board.clientHeight - rec.size, startTop + (mv.clientY - startY)));
      el.style.left = nx + 'px'; el.style.top = ny + 'px';
      rec.left = nx; rec.top = ny;
    }
    function up(){
      window.removeEventListener('pointermove', move);
      window.removeEventListener('pointerup', up);
    }
    window.addEventListener('pointermove', move);
    window.addEventListener('pointerup', up);
  });

  // resize with handle
  let resizing = false;
  handle.addEventListener('pointerdown', (ev)=>{
    ev.stopPropagation();
    resizing = true;
    const startX = ev.clientX, startY = ev.clientY;
    const startSize = rec.size;
    const startLeft = rec.left, startTop = rec.top;
    function move(mv){
      const dx = mv.clientX - startX;
      const newSize = Math.max(28, Math.min(140, Math.round(startSize + dx)));
      rec.size = newSize;
      // keep center roughly at prior center -> adjust left/top slightly
      el.style.width = newSize + 'px'; el.style.height = newSize + 'px';
      // clamp within board
      const clampLeft = Math.max(0, Math.min(board.clientWidth - newSize, startLeft));
      const clampTop = Math.max(0, Math.min(board.clientHeight - newSize, startTop));
      el.style.left = clampLeft + 'px'; el.style.top = clampTop + 'px';
      rec.left = clampLeft; rec.top = clampTop;
    }
    function up(){
      resizing = false;
      window.removeEventListener('pointermove', move);
      window.removeEventListener('pointerup', up);
    }
    window.addEventListener('pointermove', move);
    window.addEventListener('pointerup', up);
  });

  // update z-index on select for visual fronting
  el.addEventListener('pointerdown', ()=> {
    el.style.zIndex = 200;
    placed.forEach(p=>{ if (p.id !== el.dataset.id) p.el.style.zIndex = 100 + p.order; });
  });
}

/* select/deselect */
function select(id){
  // clear previous highlight
  placed.forEach(p=> p.el.style.boxShadow = 'none');
  selected = placed.find(p=>p.id===id);
  if (selected){
    selected.el.style.boxShadow = '0 12px 30px rgba(60,47,145,0.14)';
    // show size UI? We keep resizing via handle; user can also drag
  }
}

/* deselect on board tap outside */
document.addEventListener('pointerdown', (ev)=>{
  if (!ev.target.closest('.placed') && !ev.target.closest('.tool')) {
    placed.forEach(p=>p.el.style.boxShadow = 'none');
    selected = null;
  }
});

/* Undo and Reset */
document.getElementById('undo').addEventListener('click', ()=>{
  if (placed.length === 0) return;
  const last = placed.pop();
  last.el.remove();
});
document.getElementById('reset').addEventListener('click', ()=>{
  if (!confirm('모든 도형을 지우시겠습니까?')) return;
  placed.forEach(p=>p.el.remove());
  placed = []; orderCounter = 0; selected = null;
  resultContent.innerHTML = `<div class="line">도형을 배치한 뒤 '결과 보기'를 눌러주세요. (해석의 이유는 제공되지 않습니다.)</div>`;
});

/* 분석 / 결과 생성 (고급: 위치/빈도/관계 고려) */
document.getElementById('analyze').addEventListener('click', ()=>{
  if (placed.length < 4) {
    alert('선택 규칙에 따라 도형을 모두 배치하세요 (최소 4개).');
    return;
  }
  // counts & order
  const counts = {};
  placed.forEach(p=> counts[p.type] = (counts[p.type]||0) + 1);
  // dominant: if any type count===3 prefer that, else highest count
  let dominant = Object.keys(counts).find(k=>counts[k]===3) || Object.keys(counts).reduce((a,b)=> (counts[a]||0) >= (counts[b]||0) ? a : b);

  // zone detection: for each placed element compute row(col) by thirds
  function zoneOf(p){
    const cx = p.left + p.size/2;
    const cy = p.top + p.size/2;
    const col = cx < board.clientWidth/3 ? '좌측' : cx > board.clientWidth*2/3 ? '우측' : '중앙';
    const row = cy < board.clientHeight/3 ? '상단' : cy > board.clientHeight*2/3 ? '하단' : '중단';
    return {row,col};
  }

  // profile base sentences (richer)
  const profileBase = {
    circle: {
      title:'동그라미 (감성·관계형)',
      base: [
        '타인의 감정에 민감하고 공감 능력이 뛰어나며 대인관계에서 따뜻함을 전합니다.',
        '관계 속에서 역할을 조율하고 협력을 이끌 줄 아는 능력이 있습니다.',
        '상대의 심리를 세밀하게 읽어내어 중재자·상담자 같은 역할에 잘 맞습니다.',
        '다만 타인을 우선하다가 스스로의 감정이 소진될 수 있으니 자기보호가 필요합니다.'
      ],
      scent:'은은하고 포근한 플로럴·파우더리 계열의 향(라벤더·재스민 등)'
    },
    triangle: {
      title:'세모 (목표·리더형)',
      base:[
        '목표 지향적이고 결단력이 있어 팀을 이끄는 힘이 강합니다.',
        '도전과 성취에서 동기를 얻으며 빠른 판단과 실행으로 성과를 만듭니다.',
        '리더십을 발휘하지만 때로는 타인의 감정 고려가 필요할 수 있습니다.',
        '균형있는 휴식과 협의가 장기적 성과에 유리합니다.'
      ],
      scent:'시트러스·스파이시 계열의 상쾌한 향(오렌지·그레이프프룻 등)'
    },
    square: {
      title:'네모 (안정·체계형)',
      base:[
        '체계적이고 성실하여 계획을 잘 세우고 실행합니다.',
        '책임감이 강해 주변의 신뢰 대상이 되며 안정감을 제공합니다.',
        '현실적 판단과 세부 관리 능력이 뛰어납니다.',
        '유연성을 더하면 더 큰 성취를 이룰 수 있습니다.'
      ],
      scent:'우디·허브 계열의 차분한 향(샌달우드·시더 등)'
    },
    wave: {
      title:'S (창의·유연형)',
      base:[
        '상상력과 감수성이 풍부해 창의적 아이디어를 자주 떠올립니다.',
        '전통적 틀에 얽매이지 않고 새로운 방식을 시도하는 데 능합니다.',
        '예술·감성 영역에서 강점을 보이며 표현력이 뛰어납니다.',
        '구조적 반복 업무에서는 에너지가 소모될 수 있으니 보완이 필요합니다.'
      ],
      scent:'머스크·바닐라·프루티 계열의 자유로운 향'
    }
  };

  // Build synthesis: combine dominant base lines + location modifiers + interaction notes
  const domProfile = profileBase[dominant];
  // pick first 3 base lines (or rotate if fewer)
  const baseLines = domProfile.base.slice(0,3);

  // location prominence for dominant
  const domPlaced = placed.filter(p=>p.type===dominant);
  const rowCounts = {상단:0,중단:0,하단:0}; const colCounts = {좌측:0,중앙:0,우측:0};
  domPlaced.forEach(p=>{
    const z = zoneOf(p);
    rowCounts[z.row]++; colCounts[z.col]++;
  });
  const promRow = Object.keys(rowCounts).reduce((a,b)=> rowCounts[a]>rowCounts[b]?a:b);
  const promCol = Object.keys(colCounts).reduce((a,b)=> colCounts[a]>colCounts[b]?a:b);

  let locLine = '';
  if (promRow==='상단') locLine += '현재 이 성향은 외적으로 잘 드러나 행동으로 이어지고 있습니다.';
  else if (promRow==='중단') locLine += '이 성향은 내면에 잠재되어 있어 외부로 표현되기까지 시간이 걸리는 편입니다.';
  else locLine += '이 성향의 에너지가 낮아져 내부적 고민이나 부담이 있을 수 있습니다.';

  if (promCol==='우측') locLine += ' 또한 현재 자신감과 적극적 표현이 강한 상태입니다.';
  else if (promCol==='중앙') locLine += ' 전반적으로 균형이 잡혀 있어 안정감이 느껴집니다.';
  else locLine += ' 과거의 경험이나 내적 성찰이 현재 행동에 영향을 주고 있습니다.';

  // interactions: check closeness between different type centers => if many overlaps, mention tension/blend
  function dist(a,b){
    const ax = a.left + a.size/2, ay = a.top + a.size/2;
    const bx = b.left + b.size/2, by = b.top + b.size/2;
    return Math.hypot(ax-bx, ay-by);
  }
  let interactionNotes = [];
  for (let i=0;i<placed.length;i++){
    for (let j=i+1;j<placed.length;j++){
      const a=placed[i], b=placed[j];
      const d = dist(a,b);
      if (d < (a.size + b.size)/3){ // fairly close
        const pair = [a.type,b.type].sort().join('-');
        interactionNotes.push(`도형 ${labelOf(a.type)}과 ${labelOf(b.type)}이 공간적으로 가깝습니다 — 두 성향이 상호작용하며 복합적 성향을 나타낼 수 있습니다.`);
      }
    }
  }
  // remove duplicates
  interactionNotes = [...new Set(interactionNotes)];

  // final composition: 5~7 lines
  const finalLines = [];
  finalLines.push(baseLines[0]);
  finalLines.push(baseLines[1]);
  finalLines.push(baseLines[2]);
  finalLines.push(locLine);
  if (interactionNotes.length) finalLines.push(interactionNotes[0]);
  finalLines.push('종합적으로 현재의 강점을 유지하되, 필요할 때는 에너지 조절과 타협을 통해 균형을 맞추는 것이 도움이 됩니다.');

  // scent: use dominant scent
  const scent = domProfile.scent;

  // Output: two sections "성향" and "추천 향" (only the text)
  let html = `<div class="line"><strong>성향</strong></div>`;
  finalLines.forEach(l=> html += `<div class="line">• ${l}</div>`);
  html += `<div class="line"><strong>추천 향</strong></div>`;
  html += `<div class="scent">• ${scent}</div>`;

  resultContent.innerHTML = html;

  // helper label function
  function labelOf(t){
    return t === 'circle' ? '동그라미' : t === 'triangle' ? '세모' : t === 'square' ? '네모' : 'S';
  }
});
</script>

</body>
</html>